<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Resonant Engine</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Google Fonts for Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0c0a09;
            color: #d1d5db;
            overflow: hidden;
            touch-action: none; /* Prevent browser touch gestures on canvas */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>

    <canvas id="engine-canvas"></canvas>

    <!-- UI Overlay for controls -->
    <div class="absolute top-0 left-0 p-6 flex flex-col space-y-4">
        <h1 class="text-3xl font-bold text-gray-100 drop-shadow-lg">The Resonant Engine</h1>
        <p class="text-sm max-w-sm text-gray-300">
            A real-time visualization of Frequency Bonding. Drag to orbit, scroll to zoom.
        </p>
    </div>

    <script>
        window.onload = function() {
            // --- Three.js Setup ---
            const canvas = document.getElementById('engine-canvas');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Set a dynamic, subtle background color
            renderer.setClearColor(0x0c0a09, 1);

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // --- The Engine Core (The Resonant Object) ---
            const geometry = new THREE.IcosahedronGeometry(2, 5);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4f46e5,
                emissive: 0x1e3a8a,
                emissiveIntensity: 0.5,
                shininess: 100,
                specular: 0x9ca3af,
                flatShading: true,
                wireframe: false
            });
            const core = new THREE.Mesh(geometry, material);
            scene.add(core);

            // --- Entropic Particles (The Dynamic Field) ---
            const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xc084fc, wireframe: false });
            const particles = [];
            for (let i = 0; i < 500; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );
                particles.push(particle);
                scene.add(particle);
            }

            camera.position.z = 10;

            // --- Interaction Logic (Mouse & Touch) ---
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let orbitSpeed = 0.005;

            function onMouseDown(event) {
                isDragging = true;
                previousMousePosition.x = event.clientX || event.touches[0].clientX;
                previousMousePosition.y = event.clientY || event.touches[0].clientY;
            }

            function onMouseUp() {
                isDragging = false;
            }

            function onMouseMove(event) {
                if (!isDragging) return;
                const clientX = event.clientX || event.touches[0].clientX;
                const clientY = event.clientY || event.touches[0].clientY;

                const deltaX = (clientX - previousMousePosition.x) * orbitSpeed;
                const deltaY = (clientY - previousMousePosition.y) * orbitSpeed;

                core.rotation.y += deltaX;
                core.rotation.x += deltaY;

                previousMousePosition.x = clientX;
                previousMousePosition.y = clientY;
            }

            function onWheel(event) {
                const zoomSpeed = 0.01;
                camera.position.z += event.deltaY * zoomSpeed;
                if (camera.position.z < 5) camera.position.z = 5;
                if (camera.position.z > 20) camera.position.z = 20;
            }

            // Bind events for both mouse and touch
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('wheel', onWheel);

            canvas.addEventListener('touchstart', onMouseDown);
            canvas.addEventListener('touchend', onMouseUp);
            canvas.addEventListener('touchmove', onMouseMove);

            // Responsive design
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);

                // Animate the core object
                core.rotation.y += 0.002;
                core.rotation.x += 0.001;

                // Animate particles based on their distance to the core (simulating an Entropy Field)
                particles.forEach(particle => {
                    const distance = particle.position.distanceTo(core.position);
                    const force = Math.sin(Date.now() * 0.001 + distance * 0.5) * 0.005;

                    // A simple force-like effect
                    particle.position.x += force * (particle.position.x - core.position.x);
                    particle.position.y += force * (particle.position.y - core.position.y);
                    particle.position.z += force * (particle.position.z - core.position.z);
                });

                renderer.render(scene, camera);
            }

            animate();
        };
    </script>
</body>
</html>
